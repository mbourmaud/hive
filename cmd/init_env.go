package cmd

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"os"
	"strings"
)

// generateSecurePassword generates a cryptographically secure password
func generateSecurePassword(length int) (string, error) {
	bytes := make([]byte, length)
	if _, err := rand.Read(bytes); err != nil {
		return "", fmt.Errorf("failed to generate secure password: %w", err)
	}
	// Use URL-safe base64 and trim to exact length
	return base64.URLEncoding.EncodeToString(bytes)[:length], nil
}

// writeEnvFile writes the .env file with secrets
func writeEnvFile(cfg map[string]string, workers int) error {
	// .env now contains ONLY secrets - configuration is in hive.yaml
	var content strings.Builder

	content.WriteString("# ===========================================\n")
	content.WriteString("# Hive Secrets (generated by hive init)\n")
	content.WriteString("# ===========================================\n")
	content.WriteString("# This file contains SECRETS ONLY.\n")
	content.WriteString("# All configuration is in hive.yaml\n")
	content.WriteString("# DO NOT commit this file to git!\n")
	content.WriteString("# ===========================================\n\n")

	// Claude Authentication - only write what's needed based on backend
	backend := cfg["HIVE_CLAUDE_BACKEND"]
	if backend == "" {
		backend = "cli" // Default to CLI/OAuth
	}
	content.WriteString(fmt.Sprintf("HIVE_CLAUDE_BACKEND=%s\n", backend))

	switch backend {
	case "cli":
		if token := cfg["CLAUDE_CODE_OAUTH_TOKEN"]; token != "" {
			content.WriteString(fmt.Sprintf("CLAUDE_CODE_OAUTH_TOKEN=%s\n", token))
		}
	case "api":
		if key := cfg["ANTHROPIC_API_KEY"]; key != "" {
			content.WriteString(fmt.Sprintf("ANTHROPIC_API_KEY=%s\n", key))
		}
	case "bedrock":
		if profile := cfg["AWS_PROFILE"]; profile != "" {
			content.WriteString(fmt.Sprintf("AWS_PROFILE=%s\n", profile))
		}
		if region := cfg["AWS_REGION"]; region != "" {
			content.WriteString(fmt.Sprintf("AWS_REGION=%s\n", region))
		}
	}
	content.WriteString("\n")

	// Redis authentication
	redisPassword, err := generateSecurePassword(32)
	if err != nil {
		return fmt.Errorf("failed to generate Redis password: %w", err)
	}
	content.WriteString("# Redis Authentication\n")
	content.WriteString(fmt.Sprintf("REDIS_PASSWORD=%s\n", redisPassword))
	content.WriteString("\n")

	// Optional VCS tokens (user may add these)
	content.WriteString("# VCS Tokens (optional)\n")
	content.WriteString("# GITHUB_TOKEN=\n")
	content.WriteString("# GITLAB_TOKEN=\n")
	content.WriteString("\n")

	// Worker modes
	if workerMode := cfg["WORKER_MODE"]; workerMode != "" && workerMode != "hybrid" {
		content.WriteString("# Worker modes\n")
		for i := 1; i <= workers; i++ {
			content.WriteString(fmt.Sprintf("WORKER_%d_MODE=%s\n", i, workerMode))
		}
		content.WriteString("\n")
	}

	// Write to .hive/.env
	return os.WriteFile(".hive/.env", []byte(content.String()), 0600)
}

// writeMinimalEnvFile generates a minimal .env file without template
func writeMinimalEnvFile(cfg map[string]string) error {
	dockerfile := "docker/Dockerfile.node"
	if cfg["PROJECT_TYPE"] != "" {
		dockerfile = "docker/Dockerfile." + cfg["PROJECT_TYPE"]
	}

	// Generate Redis password
	redisPassword, err := generateSecurePassword(32)
	if err != nil {
		return fmt.Errorf("failed to generate Redis password: %w", err)
	}

	content := fmt.Sprintf(`# Hive Configuration
GIT_USER_EMAIL=%s
GIT_USER_NAME=%s
CLAUDE_CODE_OAUTH_TOKEN=%s
WORKSPACE_NAME=%s
GIT_REPO_URL=%s
HIVE_DOCKERFILE=%s
QUEEN_MODEL=opus
WORKER_MODEL=sonnet
AUTO_INSTALL_DEPS=true

# Redis Authentication
REDIS_PASSWORD=%s
`,
		cfg["GIT_USER_EMAIL"],
		cfg["GIT_USER_NAME"],
		cfg["CLAUDE_CODE_OAUTH_TOKEN"],
		cfg["WORKSPACE_NAME"],
		cfg["GIT_REPO_URL"],
		dockerfile,
		redisPassword,
	)

	// Write to .hive/.env
	return os.WriteFile(".hive/.env", []byte(content), 0600)
}
